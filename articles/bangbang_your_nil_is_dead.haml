-# title: bangbang your nil is dead
-# published: 2007-03-26
-# updated: 2007-08-05

:textile
  In Ruby, methods ending in question marks should return booleans.
  
  <strong class="update">Update I:</strong> the above statement is misleading, if not incorrect. You shouldn't ever need to check for equality to true or false (<code>if logged_in?</code> rather than <code>if logged_in? == true</code>), and its arguably more the Rubyish to let it "just work" rather than force it into explicitness.
  
  For example:
  <pre><code class="ruby">
  @current_user = nil
  
  def logged_in?
    @current_user
  end
  
  logged_in? == true  # => false
  logged_in? == false # =; false
  
  # hrmm, that's interesting... neither true nor false
  
  @current_user = "A pretend user object"
  
  logged_in? == true  # => false
  logged_in? == false # => false
  
  # hrmm, still neither true nor false. Who am I? Where am I? I'm confused!
  </code></pre>
  
  One way to solve this would be to redefine @logged_in?@ to look like this:
  
  <pre><code class="ruby">
  def logged_in?
    @current_user != nil # or !@current_user.nil?
  end
  </code></pre>
  
  That's alright, but there's much more succinct way to do the same thing: use the not operator (@!@) twice, or in other words; bangbang!
  
  <pre><code class="ruby">
  @current_user = nil
  
  def logged_in?
    !!@current_user
  end
  
  logged_in? == true  # => false
  logged_in? == false # => true
  
  @current_user = "A pretend user object"
  
  logged_in? == true  # => true
  logged_in? == false # => false
  
  # much better! :)
  </code></pre>
  
  ...and, if you're as sick and twisted as my colleague David Lee, you could abuse this to make a blasphemic unimplemented test method:
  
  <pre><code class="ruby">
  def test_my_code_should_do_something
    !!?!
  end
  </code></pre>
  
  The moral of the story: you usually want to chuck a double bang (@!!@) in a boolean method. The most common exception to this humble moral is that if you're just calling another boolean method (such as @include?@) from within yours you can assume it does the right thing and leave out the bangbang!
  
  <strong class="update">Update II:</strong> ignore this unmoral blasphemy. Use a double bang at your own discretion when you want to force some object into an explicit true/false. I've sometimes found it useful when I want methods ending with a question mark to return true/false.
  
  <strong class="update">Update III:</strong> I really feel I jumped the gun with this article and could have encouraged some <a href="http://www.therailsway.com/2007/8/1/dangers-of-cargo-culting">cargo culting</a> for recommending you use it in boolean methods and not explaining the double-negation itself. I also should have stated my opinion at the time more clearly: "though boolean methods work quite naturally by returning an object, nil, true or false I prefer them to always return a true or false". I see how forcing it into a boolean is un-Rubyish though I still feel there's an expectation that boolean methods return booleans, not to mention its a convention which Ruby core itself upholds
