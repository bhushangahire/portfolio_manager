-# title: Different validations for the same ActiveRecord model
-# published: 2008-01-29
-# updated: 2008-01-30

:textile
  Last night Mike was adding a feature to the "Cultural Awards 2008 website":http://culturalawards2008.lgsa.org.au/ where an admin could manually create a new user with any validly formatted email address, different to the public user registration where users can only use nsw.gov.au email addresses when registering.
  
  One approach to solving this might be to store a global "current user" from a controller's before/around filter which you'd then check when performing validations. I don't particularly like this approach for the simple problem at hand because it pushes the request/response state into the model and makes the interaction between model objects less explicit.
  
  My preferred method would be to simply have the creator of the User object specify the state under which validation should occur, and the simplest way to accomplish this is with an accessor method and the validation conditional options <code>:if</code> and <code>:unless</code>.
  
  Below we'll use <code>:if</code> and <code>:unless</code> to specify an instance method defining whether we perform this validation or not. The controller simply sets the flag on the model before requesting validation.
  
  <pre><code class="ruby">
  class User < ActiveRecord::Base
    attr_accessor :validate_as_admin
    attr_protected :validate_as_admin # Protect from mass-assignment
  
    validates_format_of :email,
                        :with => Format::NSW_GOV_EMAIL,
                        :unless => :validate_as_admin,
                        :message => "is not a valid nsw.gov.au address"
  
    validates_format_of :email,
                        :with => Format::EMAIL,
                        :if => :validate_as_admin,
                        :message => "is not a valid email address"
  end</code></pre>
  
  The existing public user registration doesn't need to change:
  
  <pre><code class="ruby">
  class UsersController < ApplicationController
    def create
      @user = User.new(params[:user])
      # @user.validate_as_admin == nil by default
      @user.save!
      redirect_to members_path
    rescue ActiveRecord::RecordInvalid
      render :action => "new"
    end
  end</code></pre>
  
  The admin section now simply sets @validate_as_admin = true@ before triggering the validation:
  
  <pre><code class="ruby">
  class Admin::UsersController < Admin::BaseController
    def create
      @user = User.new(params[:user])
      @user.validate_as_admin = true
      @user.save!
      redirect_to members_path
    rescue ActiveRecord::RecordInvalid
      render :action => "new"
    end
  end</code></pre>
  
  and that's it.
  
  It's a similar technique we used when creating "simple step-based validation":http://toolmantim.com/article/2007/11/13/simple_step_based_validation_with_activerecord.
  
  If the problem you're solving is more complex then you may consider using Jay Field's excellent <a href="http://validatable.rubyforge.org/">Validatable plugin</a> which does a whole bunch of things, one of which is validation grouping.
