-# title: Merb Routing in 0.5
-# published: 2008-01-22

:textile
  <p><a href="http://merbivore.com/">Merb</a>'s routing shiznits needs some serious documentation love. Whilst I have a shot at getting some proper docpatches together here's an overview of how to use routing in Merb 0.5.</p>
  
  <h3>Path Matching</h3>
  <p>
  The @match@ method
  defines how to route requests to controllers and actions.
  </p>
  <pre><code class="ruby">r.match("/contact").
    to(:controller => "info", :action => "contact")</code></pre>
  <p>
  You can define placeholder parts of the url with <tt>:symbol</tt> notation.
  These placeholders will be available in the params hash of your
  controllers. For example:
  </p>
  <pre><code class="ruby">r.match("/books/:book_id/:action").
    to(:controller => "books")</code></pre>
  <p>
  The placeholders can also be referenced in the <tt>to</tt> portion of the
  route if necessary:
  </p>
  <pre><code class="ruby">r.match("/admin/:module/:controller/:action/:id").
    to(:controller => ":module/:controller")</code></pre>
  <h3>Named Routes</h3>
  <p>
  Use the @name@ method on a route to give it a name:
  </p>
  <pre><code class="ruby">r.match("/contact").
    to(:controller => "info", :action => "contact").
    name(:contact)</code></pre>
  <p>
  You can then easily reference the named route from controllers and views:
  </p>
  <pre><code class="ruby">url(:contact) # => "/contact"</code></pre>
  <h3>Namespaces</h3>
  <p>
  Namespacing routes with @namespace@ is a convenient
  way of specifying both the <tt>:path_prefix</tt> and <tt>:name_prefix</tt>
  options:
  </p>
  <pre><code class="ruby">r.namespace :admin do |admin|
    admin.match("/roles").
      to(:controller => "roles", :action => "index").
      name(:roles)
  end</code></pre>
  <p>
  Reference a namespaced route by prefixing the route name with the
  namespace:
  </p>
  <pre><code class="ruby">url(:admin_roles) # => "/admin/roles"</code></pre>
  <h3>Resources</h3>
  <p>
  You can use Rails-like resource routing with @resources@:
  </p>
  <pre><code class="ruby">r.resources :posts</code></pre>
  <p>
  The routes generated are named after their resources:
  </p>
  <pre><code class="ruby">url(:posts)       #=> "/posts"
  
  @post = Post[1]
  url(:post, @post) #=> "/posts/1"</code></pre>
  <p>
  You can nest resources using the same block syntax used for namespacing:
  </p>
  <pre><code class="ruby">r.resources :posts do |p|
    p.resources :comments
  end</code></pre>
  <p>
  To refer to a nested resource route simply use the child resource's
  name. Notice in the following example there's no need to specify the
  <tt>:post_id</tt> parameter as it's automatically inferred from
  <tt>@comment</tt>.
  </p>
  <pre><code class="ruby">url(:comment, @comment) #=> "/posts/1/comments/2"</code></pre>
  <p>
  If you prefer the Rails 2 style of namespacing nested resources simply
  specify the <tt>name_prefix</tt> on the child resource:
  </p>
  <pre><code class="ruby">r.resources :posts do |p|
    p.resources :comments, :name_prefix => "post_"
  end</code></pre>
