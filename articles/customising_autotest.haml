-# title: Customising autotest
-# published: 2007-05-06

:textile
  !http://farm1.static.flickr.com/42/116680167_ada8fc1c32_m.jpg(Penumbra - by Darkmatter)!:http://flickr.com/photos/cdm/116680167/
  
  Autotest by Ryan Davis (aka <a href="http://www.zenspider.com/">ZenSpider</a>) is a sweet tool that ships with "ZenTest":http://www.zenspider.com/ZSS/Products/ZenTest/ whose job is to keep you informed of test or specification failure as you're coding your app. Whenever your source files change it reruns the applicable tests and reports the results.
  
  Autotest's usefulness shines with its dead-simple mechanism for hooking into events such as "test failed" or "all tests passed," and, as a result, ships with a bunch of useful prebuilt hooks: Autoupdate, Emacs, Fixtures, Growl, Heckle, HtmlReport, Menu, Migrate, Notify, Pretty, RedGreen, Screen, Shame, Snarl and Timestamp.
  
  Configuring autotest is done by simply creating a @.autotest@ file in your project root or home directory. It's simply a Ruby file, without the @.rb@ extension, defining your hooks or require'ing the ones that ship with ZenTest. ZenTest includes an example config, @example_dot_autotest.rb@, in the root directory of the ZenTest gem which I highly recommend checking out. Whilst you're there, have a look inside @lib/autotest@ for the various bits and bobs it ships with.
  
  I'm currently ripping the guts out of legacy app that needs redeploying&#8212;yes, I'm adding specs whilst I'm there&#8212;so to make life easier for myself I created the following @.autotest@. I've added a custom version of @AutoTest::Fixtures@ and @AutoTest::RedGreen@ to better deal with RSpec's eccentricities, and @Autotest::Speak@ to speak out test failures via Applescript.
  
  <pre><code class="ruby"># Just like Autotest::Fixtures, but for specs
  module Autotest::SpecFixtures
    Autotest.add_hook :initialize do |at|
      at.test_mappings['^spec/fixtures/(.*)s.yml'] = proc { |filename, matches|
        at.files_matching(/spec\/\w+\/\#{matches[1]}(_\w+)?.*_spec.rb$/)
      }
    end
  end
  
  # Just like Autotest::RedGreen, but for specs
  module Autotest::SpecRedGreen
    BAR = "=" * 80
  
    Autotest.add_hook :ran_command do |at|
      # TODO: submit a patch for RedGreen to make the match and code configurable
      if at.results.last.match(/^(\d+) examples?, (\d+) failures?$/)
        code = ($2 != "0") ? 31 : 32
        puts "\e[\#{code}m\#{BAR}\e[0m\n\n"
      end
    end
  end
  
  # Speak failures via Apple's speech synth
  module Autotest::Speak
    def self.speak message
      system %(osascript -e 'say "\#{message}"')
    end
  
    Autotest.add_hook :red do |at|
      failures = at.files_to_test.size
      speak "\#{failures} example\#{failures == 0 || failures > 1 ? 's' : nil} failed."
    end
  
    # Autotest.add_hook :green do |at|
    #   speak "Specs passed."
    # end
  
    Autotest.add_hook :all_good do |at|
      speak "All specs passed."
    end
  end
  </code></pre>
  
  "!http://farm1.static.flickr.com/59/215437646_f7c426183b_m.jpg(Moose head - not live - by Ed Fladung)!":http://flickr.com/photos/edfladung/215437646/
  
  The possibilities for customising autotest are endless: set up your own continuous integration using @Autotest::AutoUpdate@ with remote-growl, IRC and email notifications; or, write something that uses uses "Ruby/SerialPort":http://ruby-serialport.rubyforge.org/ to make your office's talking moose head (you do have one, don't you?) read haiku on behalf of the team member who comitted failing code.
