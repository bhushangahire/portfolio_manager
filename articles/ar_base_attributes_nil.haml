-# title: AR::Base#attributes = nil
-# published: 2007-02-14

:textile
  I just noticed a quirk of @ActiveRecord::Base#attributes=@ when writing some functional tests.
  
  Suppose I have a @SitesController@ with the following code:
  <pre><code class="ruby">
    def create
      @site = Site.new(params[:site])
      @site.save!
      flash[:notice] = "Site created"
      redirect_to site_path(@site)
    rescue ActiveRecord::RecordInvalid
      flash[:notice] = "Please correct invalid fields"
      render :action => "new"
    end
  
    def update
      @site.attributes = params[:site]
      @site.save!
      flash[:notice] = "Site udpated"
      redirect_to site_path(@site)
    rescue ActiveRecord::RecordInvalid
      flash[:notice] = "Please correct invalid fields"
      render :action => "edit"
    end
  </code></pre>
  
  When you call @create@ w/o specifying the @site@ param (i.e. <code class="ruby">params[:site] == nil</code>), you'll get a validation error back.
  
  When you call @update@ w/o specifying the @site@ param it succeeds in saving and redirects you back to the site.
  
  It turns out calling <code>@site.attributes = nil</code> does nothing to the site, and you end up just resaving it, even though no attributes were updated. Makes sense, but not really the behaviour I want.
  
  Anybody know an easy way to handle this @nil@ param case whilst still keeping the controller nice and lean?
  
  Also, what's the story with having both @attributes=@ and @update_attributes@? The only difference I see is that @update_attributes@ returns self.
