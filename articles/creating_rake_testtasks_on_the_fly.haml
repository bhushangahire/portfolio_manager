-# title: Creating Rake::TestTasks on-the-fly
-# published: 2007-02-06

:textile
  My new hacker-for-hire position at "JobFutures":http://www.jobfutures.com.au (yes, a new public site will be live in a matter of weeks) has me working on some interesting new projects, one of which is extracting out some core models into plugins to share between our applications. Each plugin is testable on its own, but we need a way to test the main application and the core plugins in one hit.
  
  My first idea was just to have a @TestTask@ to run all the test files. That seemed like a simple enough approach, the only problem though is that the test_helper's all mix into @Test::Unit::TestCase@ and set their @fixture_paths@ willy nilly.
  
  Eventually our good old friend @eval@ came to the rescue. In the code below we dynamically create <code>TestTasks</code>s, invoking them along the way.
  
  <pre><code class="ruby">
  CORE_PLUGINS = %w(jf_core_models ...)
  
  desc "Test the core plugins and the main application"
  task :the_lot do
    had_errors = false
    
    CORE_PLUGINS.each do |p|
      test_name = "test_\#{p}"
      eval <<-CODE
        Rake::TestTask.new(:\#{test_name} => :environment) do |t|
          t.libs << "test"
          t.verbose = true
          t.pattern = "vendor/plugins/\#{p}/test/**/*.rb"
        end
      CODE
      Rake::Task[test_name].invoke rescue had_errors = true
    end
    Rake::Task["test"].invoke rescue had_errors = true
  
    raise "There were test failures" if had_errors
  end
  </code></pre>
  
  The most unsexy part is the @had_errors@, but I can't think of nice why to write that. We need to catch the errors because when a @Rake::TestTask@ fails it throws an exception, but we want to run all the tests, even if some fail, and still have Ruby give the correct error return code to shell.
  
  It's not the first time lately that @eval@ has come to the rescue. I have a feeling that I'm soon going to be known around the office as "eval black magic boy".
